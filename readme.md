### Быстрый старт

```bash
docker-compose up --build
```
или через makefile
```bash
make docker-up
```

### Остановка и очистка
```bash
docker-compose down -v
```
или через makefile
```bash
make docker-down
```

### Makefile (все команды)
```bash
make docker-up      # build + run
make docker-down    # stop + remove volumes
make docker-rebuild # пересборка
make lint           # golangci-lint/ 
```

## Конфигурация окружения
Переменные берутся либо напрямую, либо через `*_FILE`. Используются:
- `DATABASE_URL` (либо `POSTGRES_USER`, `POSTGRES_PASSWORD`, `POSTGRES_DB`, `DB_HOST`, `DB_PORT`, `DB_SSLMODE`).
Fallback: `postgres://postgres:postgres@localhost:5432/app?sslmode=disable`.

## Архитектура
Слои:
- `internal/domain` — типы и константы ошибок API.
- `internal/repo` — SQL доступ к PostgreSQL (pgx / pgxpool), через паттерн маппер, никаких gorm.
- `internal/service` — бизнес‑логика (автоназначение, переназначение, статистика, массовая деактивация).
- `internal/server` — HTTP роутер (chi), маршаллинг JSON.
- `migrations` — SQL миграции (схема).
- `load/k6_pr_scenario.js` — нагрузочные тесты.
- `tests/e2e_test.go` — интеграционные тесты.

---
## Эндпоинты
Для удобства тестирования создана Postman коллекция и окружение в файлах `postman_collection.json` и `postman_environment.json`

---
## Ошибки API (коды)
| Код | Сценарий |
|-----|----------|
| `TEAM_EXISTS` | Повторное создание существующей команды |
| `PR_EXISTS` | PR с тем же ID существует |
| `PR_MERGED` | Попытка изменения ревьюверов после merge |
| `NOT_ASSIGNED` | Пользователь не был ревьювером данного PR |
| `NO_CANDIDATE` | Нет активного кандидата для замены |
| `NOT_FOUND` | Ресурс (команда/пользователь/PR) не найден |

---
## Назначение ревьюверов
- При создании PR выбираются до двух активных пользователей из команды автора (случайно `ORDER BY random()`), исключая автора.
- Если кандидатов <2 — назначается доступное количество (0 или 1, 0 по условию не запрещено так что мне кажется это нормальным исходом).
- Переназначение: проверяется статус PR (не MERGED), проверяется что old_user назначен, выбирается новый активный кандидат из команды старого ревьювера, исключая автора и текущих ревьюверов. При отсутствии кандидата — код `NO_CANDIDATE`.

## MassDeactivate оптимизация
Логика: сначала извлекаются только активные пользователи команды (если команда существует, но все уже неактивны — возвращается без действий). Затем одним запросом помечаются все пользователи команды неактивными. Открытые PR, где были назначены теперь деактивированные пользователи, проходят переработку: попытка замены на активного кандидата (если осталось хоть что‑то активное в команде), иначе удаление ревьювера. Возвращаются счётчики `reassigned` и `removed`.

Итого: один SELECT активных, один UPDATE, один SELECT по PR ревьюверам, затем для каждого PR небольшой набор запросов (обычно <=2 ревьювера).

---
## Статистика
`stats_assignments` поддерживается триггерами `AFTER INSERT/DELETE` на `pr_reviewers`. Получение — простой SELECT. Мне показалось более логичным сделать новую таблицу для статистики, чем собирать её сложными запросами.

---
## Нагрузочное тестирование
Пример запуска:
```bash
k6 run load/k6_pr_scenario.js --env BASE_URL=http://localhost:8080
```
Метрика: создание команд + PR.

---
## E2E тест
`tests/e2e_test.go` использует testcontainers (кроме Windows; можно указать `TEST_DATABASE_URL` для внешней БД). Проверяет: создание команды, создание PR, статистику, двукратный идемпотентный merge.

Запуск локально:
```bash
go test ./tests -count=1
```

---
## Линтер
Используется `golangci-lint` (конфиг в `.golangci.yml`). Включены линтеры: govet, staticcheck, revive, errcheck, ineffassign, gosimple, unused, typecheck, gocyclo, gosec, goconst. Исключения для тестовой сложности и SQL миграций. Линт запускается при сборке Docker образа (этап builder). 

Запуск вручную(на винде работать будет с костылями, да и в целом лучше пусть используется только на этапе сборки в контейнере, но оставил т.к мне было удобно применят на этапе написния кода):
```bash
make lint
```

---
## Мелочи, нюансы и прочее
- Для миграции я использовал сервис migrate, т.к мне кажется логичным и правильным делать миграции вне приложения. В таком случае мы можем гарантировано применить все миграции до старта приложения, а также легко поддерживать сразу миграции для отката и для развертывания, что также будет очень приятно и полезно в случае если миграция всё поломает. Можно будет моментально откатиться, а не бежать в панике к девопсу.
- Сборка сделано в несколько стадий, ключи мы нигде по пути не светим, а также в конце имеем один бинарь и ничего лишнего. Все слои кешируются, вынесено всё так, чтобы нам не приходилось всё очень долго билдить.
- Также добавил эндопинт `healtz` для личного удобства и быстрого теста.
- Операция мерджа идемпотентна. Мы просто ничего не делаем если мердж уже был.
- Если у пользователя isActive = false, то он может быть автором МРа, но не может быть назначен ревьюером, это полностью соответствует условию.
- Gorm не стал использовать по причине того, что быстрее нейронкой нагенерить общий код, а потом скорректировать SQL и иметь более точное понимание того что происходит.
- В .env описан пример конфигурации для потсгры.
- Хорошего вам дня :)
